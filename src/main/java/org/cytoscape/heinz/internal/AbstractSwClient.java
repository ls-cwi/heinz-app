package org.cytoscape.heinz.internal;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.charset.Charset;

/**
 * Client to run a command line tool via a simple network server wrapper.
 * 
 * Subclasses should implement methods to build command lines and retrieve
 * the output for specific tools.
 * 
 * @see <a href="https://github.com/melkebir/server-wrapper">server-wrapper</a>
 */
public abstract class AbstractSwClient {
	/**
	 * Represents a message from the client to the server wrapper.
	 */
	protected static class ClientMessage {
		
		/**
		 * Ping request, to check if the server is responsive.
		 */
		public static final int TYPE_ALIVE = 0;
		/**
		 *  A simple (non-file) parameter for the tool.
		 *  
		 *  This type of packet may have a payload, corresponding to a
		 *  second command line argument, e.g. a value for a flag.
		 */
		public static final int TYPE_PARAMETER = 10;
		/**
		 * An input file for the tool to read, referenced by filename.
		 * 
		 * The filename is generated by the server, and provided after
		 * the flag from the <code>name</code> field of the message.
		 */
		public static final int TYPE_INPUT_FILE = 20;
		/**
		 * An output file generation request.
		 * 
		 * This type of packet has no payload, the server will generate
		 * a filename when receiving the packet and provide it on the
		 * command line after the flag from the <code>name</cod> field
		 * of the message.
		 */
		public static final int TYPE_OUTPUT_FILE = 30;
		/**
		 * A request to run the command.
		 */
		public static final int TYPE_RUN = 40;
		/**
		 * An output file retrieval request.
		 * 
		 * This packet requires a name identifying the file requested.
		 * Files associated with output file generation requests are
		 * identified by numbers starting at 0, and the command’s standard
		 * output and standard error streams by 254 and 255, respectively.
		 */
		public static final int TYPE_GET_OUTPUT = 50;
		
		private final int type;
		private final String name;
		private final byte[] payload;
		
		/**
		 * Construct a new client message
		 * 
		 * @param type  the message type, see ClientMessage class constants
		 * @param name  the name (command line flag) for parameters, or null
		 * @param payload  file contents, simple parameter argument, or null
		 * 
		 * @see #TYPE_ALIVE
		 * @see #TYPE_PARAMETER
		 * @see #TYPE_INPUT_FILE
		 * @see #TYPE_OUTPUT_FILE
		 * @see #TYPE_RUN
		 * @see #TYPE_GET_OUTPUT
		 */
		public ClientMessage(int type, String name, byte[] payload) {
			this.type = type;
			this.name = name;
			this.payload = payload;
		}
		
		/**
		 * Send this message to the server.
		 * 
		 * @param stream  an output stream connected to the server
		 */
		public void send(OutputStream stream) throws IOException {
			
			// wrap the OutputStream in a DataOutputStream, which implements
			// methods for conveniently writing primitive data types
			DataOutputStream dataStream = new DataOutputStream(stream);
			
			// write the type byte
			dataStream.writeByte(type);
			
			// if a name part is specified for the message
			if (name != null) {
				// encode the name string into a byte array
				byte[] nameByteArray = name.getBytes(Charset.forName("US-ASCII"));
				// send the length of the name as four bytes,
				// high byte first (big-endian, network byte order)
				dataStream.writeInt(nameByteArray.length);
				dataStream.write(nameByteArray);
			// if no name was specified
			} else {
				// indicate a name length of 0 (four bytes, NBO)
				dataStream.writeInt(0);
			}
			
			// if a payload was specified
			if (payload != null) {
				// send the length of the payload (four bytes, NBO)
				dataStream.writeInt(payload.length);
				dataStream.write(payload);
			// if no payload was specified 
			} else {
				// indicate a payload length of 0 (four bytes, NBO)
				dataStream.writeInt(0);
			}
			
			// actually send bytes if the stream happens to be buffered
			dataStream.flush();
			
		}
		
	}
	
	/**
	 * Represents a message from the server wrapper to the client.
	 */
	protected static class ServerMessage {
		
		/**
		 * An acknowledgement that the server has processed a client message.
		 */
		public static final int TYPE_ACK = 8;
		/**
		 * An indication that the server could not process a client message.
		 */
		public static final int TYPE_NACK = 9;
		/**
		 * A package bearing an output stream as its payload.
		 */
		public static final int TYPE_OUTPUT = 59;
		
		private final int type;
		private final byte[] payload;
		
		/**
		 * Construct an object representing a (received) server message.
		 * 
		 * @param type  the message byte, see ServerMessage class constants
		 * @param payload  the payload of the message, if applicable, or null
		 * 
		 * @see #TYPE_ACK
		 * @see #TYPE_NACK
		 * @see #TYPE_OUTPUT
		 */
		private ServerMessage(int type, byte[] payload) {
			this.type = type;
			this.payload = payload;
		}
		
		/**
		 * Read a server message from an input stream.
		 * 
		 * @param stream  the stream to read from
		 * 
		 * @return  the server message read from the stream
		 * 
		 * @throws IOException  if any error occurs reading from the stream
		 * @throws EOFException  if the stream ends before the end of the message
		 */
		public static ServerMessage receive(InputStream stream)
				throws IOException {
			DataInputStream dataStream = new DataInputStream(stream);
			// read the type byte
			int type = dataStream.read();
			// read four bytes in big-endian byte order (network byte order)
			// and interpret them as an int, the length of the payload
			int payloadLength = dataStream.readInt();
			// create a byte array to store the payload
			byte[] payload = new byte[payloadLength];
			// try to fill the byte array and record the number of bytes
			// actually read
			int payloadBytesRead = dataStream.read(payload);
			if (payloadBytesRead != payloadLength) {
				throw new EOFException("Incomplete response from server.");
			}
			return new ServerMessage(type, payload);
		}
		
		/**
		 * Get the message type of this server message.
		 *  
		 * @return  the message type byte, see ServerMessage class constants
		 * 
		 * @see #TYPE_ACK
		 * @see #TYPE_NACK
		 * @see #TYPE_OUTPUT
		 */
		public int getType() {
			return type;
		}

		/**
		 * Get the payload of this server message.
		 * 
		 * @return the payload
		 */
		public byte[] getPayload() {
			return payload;
		}
		
	}
	
	private Socket socket;
	protected InputStream inputStream;
	protected OutputStream outputStream;
	
	/**
	 * Initialise a connection to the server.
	 * 
	 * @param host  host  the host name of the server
	 * @param port  the port number to connect to
	 * 
	 * @throws IOException  if a connection to a compatible server could not be made
	 * @throws UnknownHostException  if the server’s IP address could not be determined
	 */
	public AbstractSwClient (String host, int port)
			throws IOException, UnknownHostException {
		socket = new Socket(host, port);
		inputStream = socket.getInputStream();
		outputStream = socket.getOutputStream();
		
		// test if the server responds as defined in the protocol
		ping();
	}
	
	/**
	 * Test if the server is compatible and responsive.
	 * 
	 * @throws IOException  if the server does not respond as expected
	 */
	public void ping() throws IOException {
		new ClientMessage(
				ClientMessage.TYPE_ALIVE, null, null).send(outputStream);
		receiveAck();
	}
	/**
	 * Try to read an acknowledgement message from the server.
	 * 
	 * Blocking until the server responds with an ACK to signify that
	 * it has handled the last client message.
	 * 
	 * @throws IOException  if receiving something else or nothing at all.
	 */
	protected void receiveAck() throws IOException {
		ServerMessage response = ServerMessage.receive(inputStream);	
		if (!(
				response.getType() ==	ServerMessage.TYPE_ACK &&
				response.getPayload().length == 0)) {
			throw new IOException("Invalid response from server.");
		}
	}
}
